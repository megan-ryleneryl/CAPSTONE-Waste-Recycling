# Firebase Setup Guide for Recycling Platform

## Overview
This guide shows how to set up Firebase Firestore as your main database instead of MongoDB. The models are designed to work with Firebase's NoSQL document structure.

## Firebase Console Setup

### 1. Create Firebase Project
1. Go to [Firebase Console](https://console.firebase.google.com)
2. Click "Create a project"
3. Enter project name: `recycling-platform`
4. Enable Google Analytics (optional)

### 2. Enable Required Services

#### Firestore Database
1. Go to Firestore Database
2. Click "Create database"
3. Choose production mode
4. Select location closest to your users

#### Authentication
1. Go to Authentication → Sign-in method
2. Enable Email/Password
3. Optional: Enable other providers (Google, Facebook, etc.)

#### Storage
1. Go to Storage
2. Click "Get started"
3. Accept default security rules (we'll customize later)

#### Cloud Messaging (for notifications)
1. Go to Project Settings → Cloud Messaging
2. Note down Server key for later use

### 3. Get Configuration Keys
1. Go to Project Settings → General
2. Scroll to "Your apps" section
3. Click "Add app" → Web
4. Register app name
5. Copy the config object

### 4. Create Service Account
1. Go to Project Settings → Service accounts
2. Click "Generate new private key"
3. Download the JSON file
4. Rename it to `serviceAccountKey.json`

## Project Structure
```
your-project/
├── config/
│   ├── firebase.js
│   └── serviceAccountKey.json
├── models/
│   ├── User.js
│   ├── Application.js
│   ├── Post.js
│   ├── WastePost.js
│   ├── InitiativePost.js
│   ├── ForumPost.js
│   ├── Material.js
│   ├── Pickup.js
│   ├── Comment.js
│   ├── Like.js
│   ├── Message.js
│   ├── Notification.js
│   ├── Point.js
│   ├── Badge.js
│   └── Metric.js
├── services/
│   ├── authService.js
│   ├── storageService.js
│   └── notificationService.js
├── .env
└── server.js
```

## Installation

### Install Dependencies
```bash
npm install firebase firebase-admin uuid dotenv express cors helmet express-rate-limit multer
```

### Environment Variables (.env)
```env
# Firebase Config
FIREBASE_API_KEY=your_api_key
FIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_STORAGE_BUCKET=your-project.appspot.com
FIREBASE_MESSAGING_SENDER_ID=123456789
FIREBASE_APP_ID=your_app_id

# Server Config
NODE_ENV=development
PORT=3000
```

## Key Differences from MongoDB

### 1. Data Structure
- **MongoDB**: Collections with documents
- **Firestore**: Collections with documents (similar structure)
- **Relationships**: No foreign keys - use document references or subcollections

### 2. Inheritance Implementation
Instead of Mongoose discriminators, we use:
- Base `Post` class with common fields
- Subclasses (`WastePost`, `InitiativePost`, `ForumPost`) extend base class
- All stored in same `posts` collection with `postType` field

### 3. Validation
- Client-side validation in model classes
- Firestore security rules for server-side validation

### 4. Queries
- No complex joins - denormalize data when needed
- Use compound queries and array-contains for filtering
- Firestore has query limitations (e.g., no OR queries)

## Security Rules

### Firestore Rules (firestore.rules)
```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can read/write their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null; // Allow users to read other profiles
    }
    
    // Posts are readable by all authenticated users
    match /posts/{postId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && 
        (resource == null || resource.data.userID == request.auth.uid);
    }
    
    // Applications only by owner and admins
    match /applications/{applicationId} {
      allow read, write: if request.auth != null && 
        (resource.data.userID == request.auth.uid || 
         request.auth.token.userType == 'Admin');
    }
    
    // Comments readable by all, writable by authenticated users
    match /comments/{commentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == resource.data.userID;
      allow update, delete: if request.auth != null && 
        (request.auth.uid == resource.data.userID || request.auth.token.userType == 'Admin');
    }
    
    // Similar rules for other collections...
  }
}
```

### Storage Rules (storage.rules)
```javascript
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    // Only authenticated users can upload
    match /{allPaths=**} {
      allow read, write: if request.auth != null;
    }
    
    // Specific rules for different folders
    match /applications/{userId}/{fileName} {
      allow write: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null && 
        (request.auth.uid == userId || request.auth.token.userType == 'Admin');
    }
  }
}
```

## Data Modeling Best Practices

### 1. Denormalization
Since Firestore doesn't support joins, sometimes duplicate data:
```javascript
// Instead of just storing userID in posts
{
  postID: "abc123",
  userID: "user456",
  // ... other fields
}

// Also store user info for easy display
{
  postID: "abc123",
  userID: "user456",
  authorName: "John Doe", // Denormalized
  authorType: "Giver", // Denormalized
  // ... other fields
}
```

### 2. Subcollections vs Arrays
- Use **arrays** for simple lists that won't grow beyond 1MB
- Use **subcollections** for complex or large datasets

Example - Comments as subcollection:
```
posts/{postId}/comments/{commentId}
```

### 3. Atomic Operations
Use batch writes for related updates:
```javascript
const batch = writeBatch(db);
batch.set(postRef, postData);
batch.set(userRef, userData);
await batch.commit();
```

## Migration from MongoDB

### 1. Data Export/Import
- Export MongoDB data to JSON
- Transform to Firestore format
- Use Firebase Admin SDK for bulk import

### 2. Query Translation
MongoDB → Firestore query mappings:
- `find()` → `getDocs(query())`
- `findOne()` → `getDoc(doc())`
- `aggregate()` → Multiple queries + client-side processing

### 3. Real-time Features
Firestore provides real-time listeners:
```javascript
// Listen to post changes
const unsubscribe = onSnapshot(doc(db, 'posts', postId), (doc) => {
  console.log('Post updated:', doc.data());
});
```

## Performance Optimization

### 1. Indexing
Firestore creates single-field indexes automatically. Create composite indexes for complex queries via Firebase Console.

### 2. Pagination
Use cursor-based pagination:
```javascript
const first = query(collection(db, "posts"), orderBy("createdAt"), limit(25));
const documentSnapshots = await getDocs(first);

// Get next page
const last = documentSnapshots.docs[documentSnapshots.docs.length-1];
const next = query(collection(db, "posts"),
    orderBy("createdAt"), 
    startAfter(last), 
    limit(25));
```

### 3. Caching
Enable offline persistence:
```javascript
import { enableNetwork, disableNetwork } from "firebase/firestore";
// Enable offline support
await enableOfflinePersistence(db);
```

## Testing

### 1. Firestore Emulator
```bash
npm install -g firebase-tools
firebase init emulators
firebase emulators:start
```

### 2. Test Environment
```javascript
// In test files
import { connectFirestoreEmulator } from 'firebase/firestore';
const db = getFirestore();
connectFirestoreEmulator(db, 'localhost', 8080);
```

## Monitoring & Analytics

### 1. Firebase Console
- Monitor read/write operations
- Track storage usage
- View authentication stats

### 2. Cloud Functions (Optional)
Set up Cloud Functions for:
- Automatic data validation
- Background tasks
- Complex business logic

This setup gives you a fully functional Firebase Firestore database with all your recycling platform models!